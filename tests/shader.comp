#version 450

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable

struct Particle
{
	vec4 pos;
	vec4 vel;
	vec4 col;
};

layout (std430, binding = 0) buffer Pos
{
	Particle particles[];
};

layout (local_size_x = 16) in;

layout (binding = 1) uniform UBO
{
	float deltaT;
	float speed;

	float attract;
	float attractorX;
	float attractorY;
} ubo;

vec3 attraction(vec3 pos, vec3 attractPos)
{
    vec3 delta = attractPos - pos;
	const float damp = 0.5;
    float dDampedDot = dot(delta, delta) + damp;
    float invDist = 1.0f / sqrt(dDampedDot);
    float invDistCubed = invDist*invDist*invDist;
    return delta * invDistCubed * 0.00035;
}

void main()
{
    // Current SSBO index
    uint index = gl_GlobalInvocationID.x;
	// Don't try to write beyond particle count
    if (index >= particles.length())
		return;

    // Read position and velocity
    vec3 vPos = particles[index].pos.xyz;
    vec3 vVel = particles[index].vel.xyz;

	vec3 destPos = vec3(ubo.attractorX, ubo.attractorY, 0.0);

    // Calculate new velocity depending on attraction point
	if(ubo.attract != 0.0) vVel += attraction(vPos, destPos.xyz);
	vVel *= 0.995;

    // Move by velocity
	vPos += vVel * ubo.speed * ubo.deltaT * 10;

	if ((vPos.x < -1.0) || (vPos.x > 1.0))
		vVel.x -= vVel.x;

	//color
	vec3 color = particles[index].col.xyz;
	color.g = clamp(10 * sqrt(abs(vVel.x) + abs(vVel.y)), 0., 1.);

	//col.r = 1 - clamp(7 * sqrt(abs(vVel.x) + abs(vVel.y)), 0., 1.);

    // Write back
    particles[index].pos.xyz = vPos;
    particles[index].vel.xyz = vVel;
	particles[index].col.xyz = color;

}
